#pragma execution_character_set("utf-8")
#include "tcpserver.h"
#include "protocalstruct.h"
#include <QCoreApplication>
#include <QFile>
#include <QtEndian>

// 全局 map，保存所有正在写入的文件（路径 → 文件对象）
QMap<QString, QFile*> g_openFiles;

TcpServer::TcpServer(QObject *parent) : QTcpServer(parent) {}

void TcpServer::incomingConnection(qintptr socketDescriptor) {
    // 当有新的 TCP 连接进来时，Qt 会调用该函数
    QTcpSocket *client = new QTcpSocket(this);
    // 使用系统提供的 socket 描述符
    client->setSocketDescriptor(socketDescriptor);
    
    // 绑定 readyRead 信号，当客户端有数据可读时会触发
    connect(client, &QTcpSocket::readyRead, this, &TcpServer::onReadyRead);
    // 绑定 disconnected 信号，当客户端断开连接时触发
    connect(client, &QTcpSocket::disconnected, this, &TcpServer::onDisconnected);
    
    // 初始化该客户端的缓冲区
    m_buffers[client] = QByteArray();
    
    quint32 ipv4 = client->peerAddress().toIPv4Address();
    QHostAddress addr(ipv4);
    qDebug() << "=======================新的客户端连接=========================";
    qDebug() << "== ip：" << addr.toString() << "==";
    qDebug() << "== port：" << client->peerPort() << "==";
    qDebug() << "============================================================";
    qDebug(); 
    // qDebug() << "新的客户端连接: " << "[ip: "<< addr.toString()
    //          << ", port: "<< client->peerPort() << "]";
}

// 接收消息回调
void TcpServer::onReadyRead() {
    // 从 sender() 获取当前发送信号的客户端 socket
    QTcpSocket *client = qobject_cast<QTcpSocket*>(sender());
    if (!client) return;
    
    // 获取该客户端对应的缓存 buffer
    QByteArray &buffer = m_buffers[client];
    // 读取 socket 上的所有数据，追加到 buffer
    buffer.append(client->readAll());
    
    // 处理缓存中的数据（可能一次性收到了多个包）
    while (buffer.size() >= sizeof(ProtocolHeader)) {
        // 取出协议头（不移除）
        ProtocolHeader header;
        memcpy(&header, buffer.constData(), sizeof(ProtocolHeader));
        
        // 检查协议头是否合法（魔数、版本等）
        if (!header.isValid()) {
            qWarning() << "Invalid protocol header";
            client->disconnectFromHost();
            return;
        }
        
        // // 将多字节字段转换为主机字节序
        // quint16 magic = qFromBigEndian<quint16>(header.magic);
        // quint32 bodyLen = qFromBigEndian<quint32>(header.body_len);
        
        // if (magic != 0x55AA || header.version != 1) {
        //     qWarning() << "Invalid protocol header";
        //     client->disconnectFromHost();
        //     return;
        // }
        
        // 如果数据还不完整（body 还没收完），跳出等待下次 readyRead
        if (buffer.size() < sizeof(ProtocolHeader) + header.body_len)
            break;
        
        // 提取完整的消息体（JSON 部分）
        QByteArray message = buffer.mid(sizeof(ProtocolHeader), header.body_len);
        // 移除已处理的数据（头 + 体）
        buffer.remove(0, sizeof(ProtocolHeader) + header.body_len);
        // 交给消息处理函数
        processMessage(client, message);
    }
}

// // 接收消息回调(非结构体版本)
// void TcpServer::onReadyRead() {
//     QTcpSocket *client = qobject_cast<QTcpSocket*>(sender());
//     if (!client) return;
    
//     QByteArray &buffer = m_buffers[client];
//     buffer.append(client->readAll());
    
//     // 协议头固定长度：2+1+1+1+1+4 = 10
//     while (buffer.size() >= 10) {
//         // 手动读取协议头各字段
//         quint16 magic = qFromBigEndian<quint16>(*reinterpret_cast<const quint16*>(buffer.constData()));
//         quint8 version = static_cast<quint8>(buffer[2]);
//         quint8 type = static_cast<quint8>(buffer[3]);
//         quint8 flags = static_cast<quint8>(buffer[4]);
//         quint8 reserved = static_cast<quint8>(buffer[5]);
//         quint32 body_len = qFromBigEndian<quint32>(*reinterpret_cast<const quint32*>(buffer.constData() + 6));
        
//         // 校验协议头
//         if (magic != 0x55AA || version != 1) {
//             qWarning() << "Invalid protocol header";
//             client->disconnectFromHost();
//             return;
//         }
        
//         // 检查是否收到完整消息体
//         if (buffer.size() < 10 + body_len)
//             break;
        
//         // 提取消息体
//         QByteArray message = buffer.mid(10, body_len);
//         buffer.remove(0, 10 + body_len);
        
//         // 处理 JSON 消息
//         processMessage(client, message);
//     }
// }


void TcpServer::processMessage(QTcpSocket *client, const QByteArray &message) {
    qDebug() << "Received data: " << QString::fromUtf8(message);  // 打印接收到的原始数据
    
    // 将收到的 JSON 数据解析为 QJsonObject
    QJsonParseError error;
    QJsonDocument doc = QJsonDocument::fromJson(message, &error);
    if (error.error != QJsonParseError::NoError) {
        qWarning() << "JSON parse error:" << error.errorString();
        return;
    }
    
    QJsonObject json = doc.object();
    // 读取命令字段
    QString cmd = json["cmd"].toString();
    
    // 如果命令是文件传输
    if (cmd == "file_transfer") {
        QJsonObject data = json["data"].toObject();
        QString fileName = data["file_name"].toString();
        int chunkIndex = data["chunk_index"].toInt();
        QByteArray chunkData = QByteArray::fromBase64(data["chunk_data"].toString().toUtf8());
        qDebug() << "=======================接受文件数据开始=========================";
        qDebug() << "== 文件名：" << fileName << "==";
        qDebug() << "== 块索引：" << chunkIndex << "==";
        qDebug() << "== 块大小：" << chunkData.size() << "==";
        qDebug() << "==============================================================";
        qDebug();
        // qDebug() << "Received file data: " << fileName << chunkIndex << chunkData.size();
        
        // 构造文件保存路径（在当前应用目录下，以 recv_ 前缀保存）
        QString timeStamp = QDateTime::currentDateTime().toString("yyyy-MM-dd_HH-mm-ss");
        QString savePath = QCoreApplication::applicationDirPath() + "/recv_" + timeStamp + "_" + fileName;
        // qDebug() << "Saving to:" << savePath;  // 打印文件保存路径
        qDebug() << "=======================文件保存路径=========================";
        qDebug() << "== 文件保存路径：" << savePath << "==";
        qDebug() << "==============================================================";
        qDebug();
        
        // 查找是否已经打开过该文件
        QFile *file = g_openFiles.value(savePath, nullptr);
        if (!file) {
            // 如果还没打开，则新建并打开
            file = new QFile(savePath);
            if (!file->open(QIODevice::WriteOnly)) {
                qWarning() << "Cannot open file:" << savePath;
                return;
            }
            g_openFiles[savePath] = file;
        }
        
        // 将该分片写入文件
        file->write(chunkData);
        // 立即刷新到磁盘，避免缓存丢失
        file->flush();
        
        // // 打印调试信息（收到第几块，块大小，内容）
        // qDebug() << "Received chunk" << chunkIndex << "size:" << chunkData.size();
        // qDebug() << "Content of chunk:" << QString::fromUtf8(chunkData);
        
        // 构造响应包，告诉客户端该块接收成功
        QJsonObject response;
        // 回传客户端的请求序号
        response["seq"] = json["seq"].toInt();
        response["timestamp"] = QDateTime::currentSecsSinceEpoch();
        response["cmd"] = "file_transfer_ack";
        response["data"] = QJsonObject({{"chunk_index", chunkIndex}, {"status", 0}});
        response["status"] = 0;
        response["message"] = "success";
        
        sendResponse(client, response);
    }
}


void TcpServer::sendResponse(QTcpSocket *client, const QJsonObject &data) {
    // 将 JSON 数据打包成 协议头 + JSON体
    QByteArray packet = buildPacket(1, data);
    
    // 发送给客户端
    client->write(packet);
    client->flush(); // 强制刷新输出缓冲区，确保立即发送
}

// 构建包
QByteArray TcpServer::buildPacket(quint8 type, const QJsonObject &data) {
    // 1) 将 JSON 序列化成字节数组（紧凑格式）
    QJsonDocument doc(data);
    QByteArray body = doc.toJson(QJsonDocument::Compact);
    
    // 2) 填写协议头（注意：需要考虑大小端问题，后续可改进为 qToBigEndian）
    ProtocolHeader header;
    header.type = type;
    header.body_len = static_cast<quint32>(body.size());
    // // 2) 填充协议头（结构体里是主机字节序，但要转成网络字节序）
    // ProtocolHeader header;
    // header.magic    = qToBigEndian<quint16>(0x55AA);            // 魔数 (2字节，大端)
    // header.version  = 1;                                        // 协议版本 (1字节，无需大小端转换)
    // header.type     = type;                                     // 消息类型 (1字节)
    // header.flags    = 0;                                        // 标志位 (1字节)
    // header.reserved = 0;                                        // 保留字段 (2字节，大端)
    // header.body_len = qToBigEndian<quint32>(body.size());       // JSON 数据长度 (4字节，大端)
    
    // 3) 拼接成完整的数据包（头 + 体）
    QByteArray packet;
    packet.append(reinterpret_cast<const char*>(&header), sizeof(header));
    packet.append(body);
    return packet;
}
// // 构建包(非结构体)
// QByteArray TcpServer::buildPacket(quint8 type, const QJsonObject &data) {
//     // JSON 序列化
//     QJsonDocument doc(data);
//     QByteArray body = doc.toJson(QJsonDocument::Compact);
    
//     QByteArray packet;
    
//     // 手动填充协议头
//     quint16 magic = qToBigEndian<quint16>(0x55AA);
//     packet.append(reinterpret_cast<const char*>(&magic), sizeof(magic));
    
//     quint8 version = 1;
//     packet.append(reinterpret_cast<const char*>(&version), sizeof(version));
    
//     packet.append(reinterpret_cast<const char*>(&type), sizeof(type));
    
//     quint8 flags = 0;
//     packet.append(reinterpret_cast<const char*>(&flags), sizeof(flags));
    
//     quint8 reserved = 0;
//     packet.append(reinterpret_cast<const char*>(&reserved), sizeof(reserved));
    
//     quint32 body_len = qToBigEndian<quint32>(body.size());
//     packet.append(reinterpret_cast<const char*>(&body_len), sizeof(body_len));
    
//     // 拼接消息体
//     packet.append(body);
    
//     return packet;
// }


void TcpServer::onDisconnected() {
    // 获取断开连接的客户端
    QTcpSocket *client = qobject_cast<QTcpSocket*>(sender());
    if (!client) return;
    
    // qDebug() << "客户端断开连接: " << client->peerAddress().toString();
    quint32 ipv4 = client->peerAddress().toIPv4Address();
    QHostAddress addr(ipv4);
    qDebug() << "=======================新的客户端连接=========================";
    qDebug() << "== ip：" << addr.toString() << "==";
    qDebug() << "== port：" << client->peerPort() << "==";
    qDebug() << "============================================================";
    qDebug(); 
    
    // 移除其缓存 buffer
    m_buffers.remove(client);
    
    // 释放 socket 对象
    client->deleteLater();
    
    // 关闭并清理所有文件
    for (auto file : g_openFiles.values()) {
        if (file) file->close();
        delete file;
    }
    g_openFiles.clear();
}
